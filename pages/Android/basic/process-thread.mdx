# Androidè¿›ç¨‹å’Œçº¿ç¨‹ç®¡ç†é¢è¯•é¢˜

æœ¬ç« èŠ‚åŒ…å«Androidè¿›ç¨‹å’Œçº¿ç¨‹ç®¡ç†ç›¸å…³çš„é¢è¯•é¢˜ï¼Œæ¶µç›–è¿›ç¨‹ä¼˜å…ˆçº§ã€çº¿ç¨‹è°ƒåº¦ã€Handleræœºåˆ¶ç­‰æ ¸å¿ƒçŸ¥è¯†ç‚¹ã€‚

## åŸºç¡€æ¦‚å¿µ

### ğŸ”¥ é€‰æ‹©é¢˜1ï¼šAndroidè¿›ç¨‹ä¼˜å…ˆçº§

å…³äºAndroidè¿›ç¨‹ä¼˜å…ˆçº§ï¼Œä»¥ä¸‹è¯´æ³•é”™è¯¯çš„æ˜¯ï¼š

A. å‰å°è¿›ç¨‹ï¼ˆForeground Processï¼‰å…·æœ‰æœ€é«˜ä¼˜å…ˆçº§
B. å¯è§è¿›ç¨‹ï¼ˆVisible Processï¼‰åŒ…å«ç”¨æˆ·å½“å‰å¯è§ä½†ä¸å¯äº¤äº’çš„Activity
C. æœåŠ¡è¿›ç¨‹ï¼ˆService Processï¼‰çš„ä¼˜å…ˆçº§é«˜äºå‰å°è¿›ç¨‹
D. ç©ºè¿›ç¨‹ï¼ˆEmpty Processï¼‰ç”¨äºä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½ï¼Œå¯ä»¥è¢«éšæ—¶ç»ˆæ­¢

<details>
<summary>ç­”æ¡ˆä¸è§£æ</summary>

**ç­”æ¡ˆï¼šC**

è§£æï¼š
1. å‰å°è¿›ç¨‹ç¡®å®å…·æœ‰æœ€é«˜ä¼˜å…ˆçº§ï¼ŒåŒ…å«ç”¨æˆ·æ­£åœ¨äº¤äº’çš„Activity
2. å¯è§è¿›ç¨‹åŒ…å«å¯è§ä½†ä¸å¯äº¤äº’çš„Activityï¼Œå¦‚å¯¹è¯æ¡†èƒŒåçš„Activity
3. æœåŠ¡è¿›ç¨‹ä¼˜å…ˆçº§ä½äºå‰å°è¿›ç¨‹å’Œå¯è§è¿›ç¨‹ï¼Œä½†é«˜äºåå°è¿›ç¨‹
4. ç©ºè¿›ç¨‹ä¸åŒ…å«ä»»ä½•æ´»åŠ¨çš„åº”ç”¨ç»„ä»¶ï¼Œç”¨äºåŠ å¿«åº”ç”¨ä¸‹æ¬¡å¯åŠ¨é€Ÿåº¦
</details>

### ğŸ”¥ é—®ç­”é¢˜1ï¼šHandleræœºåˆ¶åŸç†

**é—®é¢˜ï¼šè¯·è¯¦ç»†è¯´æ˜Android Handleræœºåˆ¶çš„å·¥ä½œåŸç†ï¼Œä»¥åŠå¦‚ä½•æ­£ç¡®ä½¿ç”¨Handleré¿å…å†…å­˜æ³„æ¼ã€‚**

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

1. **Handleræœºåˆ¶ç»„æˆéƒ¨åˆ†**
   - Handlerï¼šå‘é€å’Œå¤„ç†æ¶ˆæ¯
   - Messageï¼šæ¶ˆæ¯å¯¹è±¡
   - MessageQueueï¼šæ¶ˆæ¯é˜Ÿåˆ—
   - Looperï¼šæ¶ˆæ¯å¾ªç¯

2. **å·¥ä½œæµç¨‹**
   - Handlerå‘é€æ¶ˆæ¯åˆ°MessageQueue
   - Looperä¸æ–­ä»MessageQueueä¸­å–å‡ºæ¶ˆæ¯
   - Handlerå¤„ç†æ¶ˆæ¯

3. **ä¸»è¦ç”¨é€”**
   - çº¿ç¨‹é—´é€šä¿¡
   - å»¶è¿Ÿæ‰§è¡Œä»»åŠ¡
   - å¤„ç†å¼‚æ­¥æ“ä½œç»“æœ

4. **é¿å…å†…å­˜æ³„æ¼çš„æ–¹æ³•**
   - ä½¿ç”¨é™æ€å†…éƒ¨ç±»
   - å¼±å¼•ç”¨æŒæœ‰å¤–éƒ¨ç±»
   - åŠæ—¶ç§»é™¤æ¶ˆæ¯
   - Activityé”€æ¯æ—¶æ¸…ç†Handler

5. **æœ€ä½³å®è·µ**
   - æ­£ç¡®ç®¡ç†Handlerç”Ÿå‘½å‘¨æœŸ
   - ä½¿ç”¨postæ–¹æ³•ç®€åŒ–ä»£ç 
   - åˆç†è®¾ç½®æ¶ˆæ¯ä¼˜å…ˆçº§
   - é¿å…é‡å¤å‘é€æ¶ˆæ¯
</details>

### ğŸ”¥ ç¼–ç¨‹é¢˜ï¼šçº¿ç¨‹æ± ç®¡ç†

**é—®é¢˜ï¼šå®ç°ä¸€ä¸ªçº¿ç¨‹æ± ç®¡ç†å·¥å…·ç±»ï¼ŒåŒ…å«å¸¸ç”¨çº¿ç¨‹æ± çš„åˆ›å»ºå’Œç®¡ç†åŠŸèƒ½ã€‚**

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

```java
public class ThreadPoolManager {
    private static ThreadPoolManager instance;
    
    // ä¸åŒç±»å‹çš„çº¿ç¨‹æ± 
    private ExecutorService cachedThreadPool;
    private ExecutorService fixedThreadPool;
    private ScheduledExecutorService scheduledThreadPool;
    private ExecutorService singleThreadExecutor;
    
    // çº¿ç¨‹æ± é…ç½®å‚æ•°
    private static final int CORE_POOL_SIZE = 5;
    private static final int MAX_POOL_SIZE = 10;
    private static final int KEEP_ALIVE_TIME = 60;
    private static final int SCHEDULED_POOL_SIZE = 3;
    
    private ThreadPoolManager() {
        initThreadPools();
    }
    
    public static ThreadPoolManager getInstance() {
        if (instance == null) {
            synchronized (ThreadPoolManager.class) {
                if (instance == null) {
                    instance = new ThreadPoolManager();
                }
            }
        }
        return instance;
    }
    
    private void initThreadPools() {
        // åˆ›å»ºç¼“å­˜çº¿ç¨‹æ± 
        cachedThreadPool = Executors.newCachedThreadPool();
        
        // åˆ›å»ºå›ºå®šå¤§å°çº¿ç¨‹æ± 
        fixedThreadPool = new ThreadPoolExecutor(
            CORE_POOL_SIZE,
            MAX_POOL_SIZE,
            KEEP_ALIVE_TIME,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        
        // åˆ›å»ºå®šæ—¶ä»»åŠ¡çº¿ç¨‹æ± 
        scheduledThreadPool = Executors.newScheduledThreadPool(SCHEDULED_POOL_SIZE);
        
        // åˆ›å»ºå•çº¿ç¨‹æ± 
        singleThreadExecutor = Executors.newSingleThreadExecutor();
    }
    
    // æ‰§è¡Œæ™®é€šä»»åŠ¡
    public void execute(Runnable task) {
        fixedThreadPool.execute(task);
    }
    
    // æ‰§è¡Œéœ€è¦è¿”å›ç»“æœçš„ä»»åŠ¡
    public <T> Future<T> submit(Callable<T> task) {
        return fixedThreadPool.submit(task);
    }
    
    // æ‰§è¡Œå®šæ—¶ä»»åŠ¡
    public ScheduledFuture<?> scheduleTask(Runnable task, long delay, TimeUnit unit) {
        return scheduledThreadPool.schedule(task, delay, unit);
    }
    
    // æ‰§è¡Œå‘¨æœŸæ€§ä»»åŠ¡
    public ScheduledFuture<?> schedulePeriodicTask(
            Runnable task, 
            long initialDelay, 
            long period, 
            TimeUnit unit) {
        return scheduledThreadPool.scheduleAtFixedRate(task, initialDelay, period, unit);
    }
    
    // åœ¨ç¼“å­˜çº¿ç¨‹æ± ä¸­æ‰§è¡Œä»»åŠ¡
    public void executeInCachedPool(Runnable task) {
        cachedThreadPool.execute(task);
    }
    
    // åœ¨å•çº¿ç¨‹æ± ä¸­æ‰§è¡Œä»»åŠ¡
    public void executeInSingleThread(Runnable task) {
        singleThreadExecutor.execute(task);
    }
    
    // å…³é—­çº¿ç¨‹æ± 
    public void shutdown() {
        if (!cachedThreadPool.isShutdown()) {
            cachedThreadPool.shutdown();
        }
        if (!fixedThreadPool.isShutdown()) {
            fixedThreadPool.shutdown();
        }
        if (!scheduledThreadPool.isShutdown()) {
            scheduledThreadPool.shutdown();
        }
        if (!singleThreadExecutor.isShutdown()) {
            singleThreadExecutor.shutdown();
        }
    }
    
    // ç«‹å³å…³é—­çº¿ç¨‹æ± 
    public void shutdownNow() {
        if (!cachedThreadPool.isShutdown()) {
            cachedThreadPool.shutdownNow();
        }
        if (!fixedThreadPool.isShutdown()) {
            fixedThreadPool.shutdownNow();
        }
        if (!scheduledThreadPool.isShutdown()) {
            scheduledThreadPool.shutdownNow();
        }
        if (!singleThreadExecutor.isShutdown()) {
            singleThreadExecutor.shutdownNow();
        }
    }
    
    // ä½¿ç”¨ç¤ºä¾‹
    public void exampleUsage() {
        // æ‰§è¡Œæ™®é€šä»»åŠ¡
        execute(() -> {
            // æ‰§è¡Œä»»åŠ¡é€»è¾‘
            System.out.println("Executing task in fixed thread pool");
        });
        
        // æ‰§è¡Œéœ€è¦è¿”å›ç»“æœçš„ä»»åŠ¡
        Future<String> future = submit(() -> {
            // æ‰§è¡Œä»»åŠ¡é€»è¾‘
            return "Task result";
        });
        
        // æ‰§è¡Œå®šæ—¶ä»»åŠ¡
        scheduleTask(() -> {
            System.out.println("Executing delayed task");
        }, 5, TimeUnit.SECONDS);
        
        // æ‰§è¡Œå‘¨æœŸæ€§ä»»åŠ¡
        schedulePeriodicTask(() -> {
            System.out.println("Executing periodic task");
        }, 0, 1, TimeUnit.MINUTES);
        
        // åœ¨ç¼“å­˜çº¿ç¨‹æ± ä¸­æ‰§è¡Œä»»åŠ¡
        executeInCachedPool(() -> {
            System.out.println("Executing task in cached thread pool");
        });
        
        // åœ¨å•çº¿ç¨‹æ± ä¸­æ‰§è¡Œä»»åŠ¡
        executeInSingleThread(() -> {
            System.out.println("Executing task in single thread pool");
        });
    }
    
    // ç›‘æ§çº¿ç¨‹æ± çŠ¶æ€çš„æ–¹æ³•
    public ThreadPoolStatus getThreadPoolStatus() {
        ThreadPoolStatus status = new ThreadPoolStatus();
        
        if (fixedThreadPool instanceof ThreadPoolExecutor) {
            ThreadPoolExecutor executor = (ThreadPoolExecutor) fixedThreadPool;
            status.activeCount = executor.getActiveCount();
            status.poolSize = executor.getPoolSize();
            status.queueSize = executor.getQueue().size();
            status.completedTaskCount = executor.getCompletedTaskCount();
        }
        
        return status;
    }
    
    // çº¿ç¨‹æ± çŠ¶æ€æ•°æ®ç±»
    public static class ThreadPoolStatus {
        public int activeCount;      // æ´»åŠ¨çº¿ç¨‹æ•°
        public int poolSize;         // çº¿ç¨‹æ± å¤§å°
        public int queueSize;        // é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡æ•°
        public long completedTaskCount; // å·²å®Œæˆçš„ä»»åŠ¡æ•°
    }
}
```

ä»£ç è¯´æ˜ï¼š
1. å®ç°äº†å®Œæ•´çš„çº¿ç¨‹æ± ç®¡ç†åŠŸèƒ½ï¼š
   - ä¸åŒç±»å‹çš„çº¿ç¨‹æ± 
   - ä»»åŠ¡æäº¤å’Œæ‰§è¡Œ
   - å®šæ—¶ä»»åŠ¡æ”¯æŒ
   - çº¿ç¨‹æ± çŠ¶æ€ç›‘æ§
2. ä½¿ç”¨å•ä¾‹æ¨¡å¼ç¡®ä¿çº¿ç¨‹æ± å…¨å±€å”¯ä¸€
3. æä¾›äº†çµæ´»çš„ä»»åŠ¡æäº¤æ–¹å¼
4. åŒ…å«çº¿ç¨‹æ± å‚æ•°é…ç½®
5. å®ç°äº†èµ„æºç®¡ç†å’Œé‡Šæ”¾
6. æä¾›äº†çŠ¶æ€ç›‘æ§åŠŸèƒ½
7. åŒ…å«å®Œæ•´çš„ä½¿ç”¨ç¤ºä¾‹
</details>